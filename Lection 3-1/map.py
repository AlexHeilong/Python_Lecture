# Функция map - применяет указанную фукцию к каждому элементу итерируемого объекта
# и возвращает итератор с новыми объектами
# f(x) => x + 10
# map(f, [1, 2, 3, 4, 5])
#        [11,12,13,14,15]
# Нельзя пройтись дважды
#
# li = [x for x in range(1, 20)] # простой способ сгенерировать список
# print(li) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# li = list(map(lambda x:x+10, li)) # реализация вышеописанного выражения (функции) при помощи lambda
# print(li) #[11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
# ____________________

# Еще вариант использования мар

# data = list(map(int, input().split())) # Реализация приведения в список с числами: первый аргумент int - функция приводящая к числу из строки;
#                                  # ...split() - приводит строку к удобоворимому варианту для применения функции int
# print(data)

# Еще вариант:
# data = map(int, '1 2 3 4'.split()) # т.е. можно использовать и таким образом, но данный тип итеррирует только один раз
# for e in data: # поэтому данные желательно где-то сохранить, поэтому с "мар" используют list(map())
#     print(e)
# print(';,.,;')
# for e in data:
#     print(e)
# ______________
# Преобразуем немного код из прошлого примера:

# Удаляем функцию select

def where(f, col): # Еще одна функция, которая принимает функцию и набор данных
    return [x for x in col if f(x)]
data = '1, 2, 3, 5, 8, 15, 23, 38'.replace(',', ' ').split()

result = map(int, data) # вместо select сразу вписываем функцию "map"
result1 = where(lambda x: x%2==0, result)
# result1 = where(lambda x: not x%2, result) - тоже самое
print(result1)
result2 = list(map(lambda x: (x, x**2), result1))
print(result2)